/*
 * Copyright 2025 Morse Micro
 * 
 * Smart Manager - Morse Control Interface API
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#ifndef SRC_BACKEND_MORSECTRL_MORSE_COMMANDS_H_
#define SRC_BACKEND_MORSECTRL_MORSE_COMMANDS_H_

#include <stdint.h>

#ifdef MORSE_WIN_BUILD
#include <winsock2.h>
#include <windows.h>
#endif

#include <endian.h>

#define PACKED __attribute__((packed))

#define MORSE_CMD_SEMVER_MAJOR  56
#define MORSE_CMD_SEMVER_MINOR  3
#define MORSE_CMD_SEMVER_PATCH  0

#define MORSE_CMD_TYPE_REQ  BIT(0)
#define MORSE_CMD_TYPE_RESP BIT(1)
#define MORSE_CMD_TYPE_EVT  BIT(2)

#define MORSE_CMD_SSID_MAX_LEN  32
#define MORSE_CMD_MAC_ADDR_LEN  6

enum morse_cmd_id {
    /* Standard commands starting at 0x0000 */
    MORSE_CMD_ID_SET_CHANNEL            = 0x0001,
    MORSE_CMD_ID_GET_VERSION            = 0x0002,

    /* Driver commands starting at 0xA000 */
    MORSE_CMD_ID_DRIVER_START           = 0xA000,
    MORSE_CMD_ID_GET_AVAILABLE_CHANNELS = 0xA011,
    MORSE_CMD_ID_OCS_DRIVER             = 0xA017,
    MORSE_CMD_ID_CONFIG_RAW             = 0xA021,
    MORSE_CMD_ID_CONFIG_BSS_STATS       = 0xA022,
    MORSE_CMD_ID_DRIVER_END,

    /* Events starting at 0x4000 */
    MORSE_CMD_ID_EVT_OCS_DONE           = 0x4006,
};

/**
 * MAC address structure
 */
struct PACKED morse_cmd_mac_addr
{
    uint8_t octet[MORSE_CMD_MAC_ADDR_LEN];
};

enum morse_cmd_ocs_subcmd {
    MORSE_CMD_OCS_SUBCMD_CONFIG = 1,
    MORSE_CMD_OCS_SUBCMD_STATUS = 2,
};

/**
 * The header for a command
 */
struct PACKED morse_cmd_header
{
    /** Flags - used between host and firmware */
    __le16 flags;
    /** Message id - from enum morse_commands_id */
    __le16 message_id;
    /** Command length excluding the header */
    __le16 len;
    /** Host sequence id - used between host and firmware only */
    __le16 host_id;
    /** Interface id - set by the host and copied into the response */
    __le16 vif_id;
    /** Padding for word alignment */
    __le16 pad;
};

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured bandwidth to
 * be used.
 */
#define MORSE_CMD_CHANNEL_BW_NOT_SET 0xFF

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured channel index
 * to be used.
 */
#define MORSE_CMD_CHANNEL_IDX_NOT_SET 0xFF

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured frequency to
 * be used.
 */
#define MORSE_CMD_CHANNEL_FREQ_NOT_SET 0xFFFFFFFF

enum morse_cmd_dot11_proto_mode {
    /** 802.11ah S1G mode */
    MORSE_CMD_DOT11_PROTO_MODE_AH       = 0,
    /** 802.11b (DSSS only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_B        = 1,
    /** 802.11bg (Legacy only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_BG       = 2,
    /** 802.11gn (OFDM only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_GN       = 3,
    /** 802.11bgn (Full compatibility) mode */
    MORSE_CMD_DOT11_PROTO_MODE_BGN      = 4,
    /** Invalid mode, PHY is not configured */
    MORSE_CMD_DOT11_PROTO_MODE_INVALID  = 5,
};

/**
 * morse_cmd_req_set_channel - request message for SET_CHANNEL
 *
 * In 802.11ah a BSS supports operating channel widths of 1, 2, 4, 8 and 16 MHz
 * and is required to use a 1MHz or 2MHz primary channel width.
 * Additionally 11ah requires that a 1MHz sub band channel must be available at all
 * operating channel widths regardless of the primary channel width.
 * The location of the 1MHz channel must be contained within the 1/2MHz primary channel.
 * The location of the 1MHz channel within the operating channel can be defined with
 * an integer index.
 *
 * For example, shown is an 8MHz operating channel with a 2MHz primary bandwidth
 * and the 1MHz channel at index 1:
 *
 * | <--------- 8MHz operating channel ----------> | Operating channel
 * | ----4MHz primary----- | ----4MHz secondary--- | 8MHz packet
 * | 2MHz Prim | 2MHz Sec  | --------------------- | 4MHz packet
 * | 2MHz Prim | --------------------------------- | 2MHz packet
 * | --- | 1MH | --------------------------------- | 1MHz packet
 *
 * | -0- | -1- | -2- | -3- | -4- | -5- | -6- | -7- | 1MHz Channel index
 * | ----0---- | ----1---- | ----2---- | ----3---- | 2MHz Channel index
 * | ----------0---------- | ----------1---------- | 4MHz Channel index
 * | ----------------------0---------------------- | 8MHz Channel index
 *
 * The index of the next higher sub band can be calculated by
 * floor(primary_1mhz_channel_index / sub_band_width).
 * E.g. if the 1MHz channel index is 3, the 2MHz primary is at floor(3/2) = 1
 */
struct PACKED morse_cmd_req_set_channel
{
    /** Center frequency of the operating channel */
    __le32 op_chan_freq_hz;
    /** Operating channel bandwidth in MHz */
    uint8_t op_bw_mhz;
    /** Primary channel bandwidth in MHz */
    uint8_t pri_bw_mhz;
    /**
     * The index of the 1MHz channel within the operating channel. This is a value 0 for 1MHz
     * channel, 0-1 for 2MHz, 0-3 for 4MHz, 0-7 for 8MHz and 0-15 for 16MHz.
     */
    uint8_t pri_1mhz_chan_idx;
    /** enum morse_cmd_dot11_proto_mode */
    uint8_t dot11_mode;
    /**
     * Flag set to 1 to set the S1G TX power to the regulatory max, 0 to skip setting. 1 by default.
     * Used for debug on the driver only. Excluded from firmware.
     */
    uint8_t reg_tx_power_set;
};

/**
 * morse_cmd_resp_set_channel - response message for SET_CHANNEL
 *
 * Returns the power of the channel set
 */
struct PACKED morse_cmd_resp_set_channel
{
    /** Power in qdBm */
    __sle32 power_qdbm;
};

/** Maximum length of the version string */
#define MORSE_CMD_MAX_VERSION_LEN 128

/**
 * morse_cmd_req_get_version - request message for GET_VERSION
 */
struct PACKED morse_cmd_req_get_version
{
};

/**
 * morse_cmd_resp_get_version - response message for GET_VERSION
 *
 * Structure for a get version confirm
 */
struct PACKED morse_cmd_resp_get_version
{
    /** Length of version */
    __sle32 length;
    /**
     * The version string. Variable length for the firmware. Use MORSE_CMD_MAX_VERSION_LEN to set
     * size elsewhere.
     */
    uint8_t version[];
};

#define MORSE_CMD_MAX_AVAILABLE_CHANNELS 255

/**
 * Channel information for get available channels. Structure should not vary from that of struct
 * morse_channel in dot11ah.h in the driver as channel information is derived from this definition.
 */
struct PACKED morse_cmd_channel_info
{
    __le32 frequency_khz;
    uint8_t channel_5g;
    uint8_t channel_s1g;
    uint8_t bandwidth_mhz;
};

/**
 * morse_cmd_resp_get_available_channels - response message for GET_AVAILABLE_CHANNELS
 */
struct PACKED morse_cmd_resp_get_available_channels
{
    __le32 num_channels;
    struct morse_cmd_channel_info channels[MORSE_CMD_MAX_AVAILABLE_CHANNELS];
};

/**
 * Command request structure for OCS commands to the driver
 */
struct PACKED morse_cmd_ocs_driver_req
{
    __le32 op_channel_freq_hz;
    uint8_t op_channel_bw_mhz;
    uint8_t pri_channel_bw_mhz;
    uint8_t pri_1mhz_channel_index;
};

/**
 * Command response structure for OCS commands to the driver
 */
struct PACKED morse_cmd_ocs_driver_resp
{
    uint8_t running;
};

/**
 * morse_cmd_req_ocs_driver - request message for OCS_DRIVER
 */
struct PACKED morse_cmd_req_ocs_driver
{
    /** Subcommand value @ref morse_cmd_ocs_subcmd */
    __le32 subcmd;
    union {
        uint8_t opaque[0];
        struct morse_cmd_ocs_driver_req config;
    };
};

/**
 * morse_cmd_resp_ocs_driver - response message for OCS_DRIVER
 *
 * @note driver response should not differ from the firmware response @ref struct morse_cmd_resp_ocs
 */
struct PACKED morse_cmd_resp_ocs_driver
{
    /** Subcommand value @ref morse_cmd_ocs_subcmd */
    __le32 subcmd;
    union {
        uint8_t opaque[0];
        struct morse_cmd_ocs_driver_resp ocs_status;
    };
};

#define MORSE_CMD_CFG_RAW_FLAG_ENABLE   BIT(0)
#define MORSE_CMD_CFG_RAW_FLAG_DELETE   BIT(1)
#define MORSE_CMD_CFG_RAW_FLAG_UPDATE   BIT(2)
#define MORSE_CMD_CFG_RAW_FLAG_DYNAMIC  BIT(3)

enum morse_cmd_raw_tlv_tag {
    MORSE_CMD_RAW_TLV_TAG_SLOT_DEF      = 0,
    MORSE_CMD_RAW_TLV_TAG_GROUP         = 1,
    MORSE_CMD_RAW_TLV_TAG_START_TIME    = 2,
    MORSE_CMD_RAW_TLV_TAG_PRAW          = 3,
    MORSE_CMD_RAW_TLV_TAG_BCN_SPREAD    = 4,
    MORSE_CMD_RAW_TLV_TAG_DYN_GLOBAL    = 5,
    MORSE_CMD_RAW_TLV_TAG_DYN_CONFIG    = 6,
    MORSE_CMD_RAW_TLV_TAG_LAST          = 7,
};

/**
 * Slot definition is required for new raw configs
 */
struct PACKED morse_cmd_raw_tlv_slot_def
{
    uint8_t tag;
    /** Total length of the RAW window. @ref raw_duration_us / num_slots = slot_duration */
    __le32 raw_duration_us;
    /** Number of individual "slots" within the RAW window */
    uint8_t num_slots;
    uint8_t cross_slot_bleed;
};

/**
 * RAW group information
 */
struct PACKED morse_cmd_raw_tlv_group
{
    uint8_t tag;
    /** Start AID for this raw config */
    __le16 aid_start;
    /** End AID for this config (inclusive) */
    __le16 aid_end;
};

/**
 * RAW start time information
 */
struct PACKED morse_cmd_raw_tlv_start_time
{
    uint8_t tag;
    /** Time the RAW window starts, measured from the end of the frame carrying RPS IE */
    __le32 start_time_us;
};

/**
 * Periodic RAW information
 */
struct PACKED morse_cmd_raw_tlv_praw
{
    uint8_t tag;
    uint8_t periodicity;
    uint8_t validity;
    uint8_t start_offset;
    uint8_t refresh_on_expiry;
};

/**
 * RAW beacon spreading information
 */
struct PACKED morse_cmd_raw_tlv_bcn_spread
{
    uint8_t tag;
    __le16 max_spread;
    __le16 nominal_sta_per_bcn;
};

/**
 * Global configuration for dynamic RAW configuration
 */
struct PACKED morse_cmd_raw_tlv_dyn_global
{
    uint8_t tag;
    /** Number of dynamic RAW confgis present */
    __le16 num_configs;
    /** The maximum number of beacon frames to add RAW configs to */
    __le16 num_bcn_indexes;
};

/**
 * Single dynamic RAW config entry in the batch of RAW configs
 */
struct PACKED morse_cmd_raw_tlv_dyn_config
{
    uint8_t tag;
    /** Unique config id of dynamic RAW config entry */
    __le16 id;
    /** Index of beacon to include this RAW config into */
    __le16 index;
    /** Length of RAW config */
    __le16 len;
    /** RAW TLV data */
    uint8_t variable[];
};

/**
 * RAW TLV data
 */
union PACKED morse_cmd_raw_tlvs
{
    uint8_t tag;
    struct morse_cmd_raw_tlv_slot_def slot_def;
    struct morse_cmd_raw_tlv_group group;
    struct morse_cmd_raw_tlv_start_time start_time;
    struct morse_cmd_raw_tlv_praw praw;
    struct morse_cmd_raw_tlv_bcn_spread bcn_spread;
    struct morse_cmd_raw_tlv_dyn_global dyn_global;
    struct morse_cmd_raw_tlv_dyn_config dyn_config;
};

/**
 * morse_cmd_req_config_raw - request message for CONFIG_RAW
 */
struct PACKED morse_cmd_req_config_raw
{
    /** Flags for this RAW config */
    __le32 flags;
    /**
     * ID to reference this RAW config. If ID already exists, existing config will be overwritten.
     * ID of 0 is reserved to indicate operate on RAW globally.
     */
    __le16 id;
    /** RAW TLV data */
    uint8_t variable[];
};

/**
 * morse_cmd_req_config_bss_stats - request message for CONFIG_BSS_STATS
 */
struct PACKED morse_cmd_req_config_bss_stats
{
    /** Flag to enable or disable the module */
    uint8_t enable;
    /** BSS statistics reporting interval in msec */
    __le32 monitor_window_ms;
};

/**
 * morse_cmd_evt_ocs_done - event message for OCS_DONE
 */
struct PACKED morse_cmd_evt_ocs_done
{
    __le64 time_listen;
    __le64 time_rx;
    int8_t noise;
    uint8_t metric;
};

#endif // SRC_BACKEND_MORSECTRL_MORSE_COMMANDS_H__
